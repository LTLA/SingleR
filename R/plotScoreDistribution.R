#' Plot score distributions 
#'
#' Plot the distribution of assignment scores across all cells assigned to each reference label.
#'
#' @param results A \linkS4class{DataFrame} containing the output from \code{\link{SingleR}}, 
#' \code{\link{classifySingleR}}, \code{\link{combineCommonResults}}, or \code{\link{combineRecomputedResults}}.
#' @param show Deprecated, use \code{\link{plotDeltaDistributions}} instead for \code{show!="scores"}.
#' @param labels.use Character vector specifying the labels to show in the plot facets.
#' Defaults to all labels in \code{results}.
#' @param scores.use Integer scalar or vector specifying the individual annotation result from which to take scores.
#' This is only relevant for combined results, see Details.
#' @param calls.use Integer scalar or vector specifying the individual annotation result from which to take labels.
#' This is only relevant for combined results, see Details.
#' @param calls.use Integer scalar or vector specifying the individual annotation result from which to take pruned labels.
#' This is only relevant for combined results, see Details.
#' @param dots.on.top Logical scalar specifying whether cell dots should be plotted on top of the violin plots.
#' @param this.color String specifying the color for cells that were assigned to the label.
#' @param pruned.color String specifying the color for cells that were assigned to the label but pruned.
#' @param other.color String specifying the color for other cells not assigned to the label.
#' @param size Numeric scalar to set the size of the dots.
#' @param ncol Integer scalar to set the number of labels to display per row.
#' @param show.nmads,show.min.diff,grid.vars Deprecated, use \code{\link{plotDeltaDistributions}} instead.
#' @param grid.vars Named list of extra variables to pass to \code{\link[gridExtra]{grid.arrange}},
#' used to arrange the multiple plots generated when \code{scores.use} is of length greater than 1.
#'
#' @return
#' If \code{scores.use} specifies a single set of scores,
#' a \link[ggplot2]{ggplot} object is returned showing the scores in violin plots.
#'
#' If \code{scores.use} specifies multiple scores for a combined result,
#' multiple ggplot objects are generated in a grid on the current graphics device.
#' 
#' If \code{score.use} specifies multiple scores and \code{grid.vars} is set to \code{NULL},
#' a list is returned containing the ggplot objects for manual display.
#'
#' @details
#' This function creates jitter and violin plots showing assignment scores for all cells across one or more labels.
#' Each facet represents a label in \code{labels.use} and contains three violin plots:
#' \itemize{
#' \item \dQuote{Assigned}, containing scores for all cells assigned to that label.
#' Colored according to \code{this.color}.
#' \item \dQuote{Pruned}, containing scores for all cells assigned to that label but pruned out.
#' Colored according to \code{pruned.color}.
#' \item \dQuote{Other}, containing the scores for all cells assigned to other labels.
#' Colored according to \code{other.color}.
#' }
#' The expectation is that the former is higher than the latter,
#' though the deltas generated by \code{\link{plotDeltaDistribution}} are often more informative in this regard.
#'
#' For combined results (see \code{?"\link{combine-predictions}"}),
#' this function can show both the combined and individual scores or labels.
#' This is done using the \code{scores.use} and \code{labels.use} arguments,
#' entries of which refer to columns of \code{results$orig.results} if positive or to the combined results if zero.
#' For example:
#' \itemize{
#' \item If we set \code{scores.use=2} and \code{labels.use=1},
#' we will plot the scores from the second individual reference against the labels predicted from the first reference.
#' \item If we set \code{scores.use=1:2} and \code{labels.use=0},
#' we will plot the scores from first and second references (in separate plots) against the combined labels.
#' \item By default, the function will create a plot for the combined scores and each individual reference.
#' In each plot, the scores are shown against the combined labels. 
#' }
#'
#' @seealso
#' \code{\link{SingleR}}, to generate scores.
#'
#' \code{\link{pruneScores}}, to remove low-quality labels based on the scores, and to see more about the quailty cutoffs.
#'
#' \code{\link[gridExtra]{grid.arrange}}, for tweaks to the how plots are arranged when multiple are output together.
#'
#' @author Daniel Bunis and Aaron Lun
#' @examples
#' example(SingleR, echo=FALSE)
#'
#' # To show the distribution of scores grouped by label:
#' plotScoreDistribution(results = pred)
#'
#' # We can display a particular label using the label
#' plotScoreDistribution(results = pred,
#'     labels.use = "B")
#'
#' # When SingleR is run with multiple references, default output will contain
#' # separate plots for each original reference, as well as for the the combined
#' # set when 'show' = "scores".
#' example(combineRecomputedResults, echo = FALSE)
#' plotScoreDistribution(results = combined)
#'
#' # 'scores.use' sets which original results to plot distributions for, and can
#' # be multiple or NULL (default)
#' plotScoreDistribution(results = combined, scores.use = 0)
#' plotScoreDistribution(results = combined, scores.use = 1:2)
#'
#' # To have plots output in a grid rather than as separate pages, provide,
#' # a list of inputs for gridExtra::grid.arrange() to 'grids.vars'.
#' plotScoreDistribution(combined, grid.vars = list(ncol = 1))
#'
#' # An empty list will use grid.arrange defaluts
#' plotScoreDistribution(combined, grid.vars = list())
#'
#' @export
plotScoreDistribution <- function(
    results,
    show = c("scores", "delta.med", "delta.next"),
    labels.use = colnames(results$scores),
    scores.use = NULL,
    calls.use = 0,
    pruned.use = 0,
    size = 0.5,
    ncol = 5,
    dots.on.top = TRUE,
    this.color = "#F0E442",
    pruned.color = "#E69F00",
    other.color = "gray60",
    show.nmads = 3,
    show.min.diff = NULL,
    grid.vars = list())
{
    results <- .ensure_named(results)
    show <- match.arg(show)
    is.combined <- !is.null(results$orig.results)
    ref.names <- colnames(results$orig.results)

    if (is.null(scores.use)) {
        scores.use <- c(0L, seq_along(results$orig.results)) # seq_along(NULL) is nothing.
    }
    calls.use <- rep(calls.use, length.out=length(scores.use))
    pruned.use <- rep(pruned.use, length.out=length(scores.use))

    plots <- vector("list", length(scores.use))
    for (i in seq_along(plots)) {

        # Pulling out the scores to use in this iteration.
        chosen.scores <- scores.use[i]
        if (chosen.scores==0L) {
            score.results <- results
        } else {
            score.results <- results$orig.results[[chosen.scores]]
        }

        scores <- score.results$scores
        tuning.scores <- score.results$tuning.scores
        scores.title <- .values_title(is.combined, chosen.scores, ref.names, show)

        # Pulling out the labels to use in this iteration.
        chosen.calls <- calls.use[i]
        if (chosen.calls==0L) {
            call.results <- results
        } else {
            call.results <- results$orig.results[[chosen.calls]]
        }

        labels <- call.results$labels
        labels.title <- .values_title(is.combined, chosen.calls, ref.names, "Labels")

        # Pulling out the pruning calls to use in this iteration.
        chosen.pruned <- pruned.use[i]
        if (chosen.pruned==0L) {
            prune.results <- results
        } else {
            prune.results <- results$orig.results[[chosen.pruned]]
        }

        prune.calls <- prune.results$pruned.labels
        prune.title <- .values_title(
            is.combined, chosen.pruned, paste0("(",ref.names,")"), "pruned")

        # Calculate nmad.cutoff values for 'show.nmads'
        if (show == "delta.med" && !is.null(show.nmads)) {
            nmad.vals <- pruneScores(score.results, get.thresholds=TRUE, nmads = show.nmads)
        }

        # Actually creating the plot
        plots[[i]] <- .plot_score_distribution(
            scores=scores, labels=labels, prune.calls=prune.calls, labels.use=labels.use, 
            labels.title=labels.title, scores.title=scores.title, prune.title=prune.title,
            this.color=this.color, pruned.color=pruned.color, other.color=other.color, 
            size=size, ncol=ncol, dots.on.top=dots.on.top)
    }

    if (length(plots)==1L) {
        # Doing this to be consistent with raw ggplot output.
        plots[[1]]
    } else {
        if (!is.null(grid.vars) && length(scores.use) > 1L) {
            do.call(gridExtra::grid.arrange, c(plots, grid.vars))
        } else {
            plots
        }
    }
}

.plot_score_distribution <- function(
    scores, labels, prune.calls, labels.use,
    labels.title, scores.title, prune.title,
    this.color, pruned.color, other.color, size, ncol, dots.on.top)
{
    # Create a dataframe with separate rows for each score in values.
    df <- data.frame(
        label = rep(colnames(scores), nrow(scores)),
        values = as.numeric(t(scores)),
        stringsAsFactors = FALSE)

    # Add whether this label is the final label given to each cell.
    df$cell.calls <- rep("other", nrow(df)) # rep() protects when nrow(df)=0.
    is.called <- df$label == rep(labels, each=ncol(scores))
    df$cell.calls[is.called] <- "assigned"

    # Replace cell.call if cell was pruned.
    if (!is.null(prune.calls)) {
        is.pruned <- rep(is.na(prune.calls), each=ncol(scores))
        df$cell.calls[is.pruned & is.called] <- prune.title
    }

    # Trim dataframe by labels
    keep <- df$label %in% labels.use
    if (any(keep)) {
        df <- df[keep,]
    } else {
        warning("ignoring 'labels.use' as it has no values in ", scores.title)
    }

    # Making the violin plots.
    p <- ggplot2::ggplot(data = df,
            ggplot2::aes_string(x = "cell.calls", y = "values", fill = "cell.calls")) +
        ggplot2::scale_fill_manual(
            name = labels.title,
            breaks = c("assigned", prune.title, "other"),
            values = c(this.color, pruned.color, other.color))

    .pretty_violins(p, df=df, ncol=ncol, scores.title=scores.title, 
        size=size, dots.on.top=dots.on.top)
}

.pretty_violins <- function(p, df, ncol, scores.title, size, dots.on.top) {
    p <- p + ggplot2::theme_classic() +
        ggplot2::facet_wrap(facets = ~label, ncol = ncol) +
        ggplot2::ylab(scores.title)
    
    if (nlevels(as.factor(df$label)) == 1) {
        p <- p + ggplot2::scale_x_discrete(name = NULL, labels = NULL)
    } else {
        p <- p + ggplot2::scale_x_discrete(name = "Labels", labels = NULL)
    }

    # Adding the data:
    jit <- ggplot2::geom_jitter(height = 0, width = 0.3, color = "black",
        shape = 16, size = size, na.rm = TRUE)

    if (!dots.on.top) {
        p <- p + jit
    }

    p <- p + ggplot2::geom_violin(na.rm=TRUE)

    if (dots.on.top) {
        p <- p + jit
    }

    p
}
